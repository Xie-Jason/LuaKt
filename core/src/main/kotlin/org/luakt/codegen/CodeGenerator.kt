package org.luakt.codegen

import org.luakt.lib.Lib
import org.luakt.lib.LuaTable
import org.luakt.parse.LuaScript
import org.luakt.syntax.*
import org.luakt.syntax.UniOpType.*
import org.luakt.util.Path
import org.luakt.util.config.BuildConfig
import kotlin.experimental.or

class CodeGenerator(
    private val rootScript : LuaScript,
    private val config : BuildConfig
){
    private val outputClassFiles = mutableListOf<ClassFile>()

    fun generate() : List<ClassFile>{
        rootScript.requires.values.forEach(::generate)
        generate(rootScript)
        // only once
        generateGlobals(rootScript.globals)
        return outputClassFiles
    }

    private fun generate(script : LuaScript){
        val name = Path.fileNameOfPath(script.file)
        val file = ClassFile(Path.toStdName(name), Type.Cls.MOD)
        file.setPath(script.file, script.outputFile)
        generateFields(file, script.fields)
        generateMain(file)
        generateModuleCall(file, script.fnCount)
        generate(FnGenContext(
            Name.Exec,
            script.meta,
            script.body,
            script.globals,
            file
        ))
        outputClassFiles.add(file)
    }

    private object Name {
        const val Arg = "arg"
        const val Main = "main"
        const val Init = "init"
        const val Exec = "exec"
        const val Call = "call"
        const val Judge = "judge"
        const val Flatten = "flatten"
        const val Make = "make"
        const val Access = "access"
        const val Put = "put"
        const val Next = "next"
        const val State = "state"
        const val Require = "require"
        const val ValueOf = "valueOf"
    }

    private fun generateGlobals(globals: Map<String, Location>){
        val file = ClassFile(Type.Cls.STATE, Type.Cls.OBJ)
        // TODO add access for LuaState
        // file.addInterface(Type.Cls.STATE_HOLDER)
        globals.toList().sortedBy { it.second.idx }.forEach {
            file.addField(toVarName(it.second), isPub = true)
        }
        // add function make
        val codes = Codes(file)
        generateInvokeDefaultNew(Type.Cls.STATE, codes, file)
        codes.put(ByteCode.AStore, 0.toByte())
        sequenceOf(Lib.global)
            .map(LuaTable::keys)
            .forEach { fieldSet ->
                fieldSet.forEach{
                    codes.put(ByteCode.ALoad, 0.toByte())
                    val getName = toLibFnName(it as String)
                    codes.put(
                        ByteCode.GetStatic,
                        file.useField(Type.Cls.LIB, getName, Type.obj)
                    )
                    val putName = toVarName(globals[getName]!!)
                    codes.put(
                        ByteCode.PutField,
                        file.useField(Type.Cls.STATE, putName, Type.obj)
                    )
                }
            }
        codes.put(ByteCode.ALoad, 0.toByte())
        codes.put(ByteCode.AReturn)
        file.addFn(
            Name.Make,
            ClassFile.Flag.Public or ClassFile.Flag.Static,
            1U,
            Type.method(null, Type.state),
            codes
        )
        file.setPath("<AutoGenerated>", "${config.outDir}LuaState.class")
        outputClassFiles.add(file)
    }

    private fun toLibFnName(name : String) : String{
        // avoid java syntax key word
        return when(name){
            "assert" -> "_$name"
            else -> name
        }
    }
    
    private fun generateFields(file: ClassFile, fields : Set<Pair<Int,String>>){
        fields.map { toVarName(Location.asField(it.first, it.second)) }
            .forEach(file::addField)
        file.addField(Name.State, Type.obj, true)
        // add setState method
        val codes = Codes(file)
        codes.put(ByteCode.ALoad, 0.toByte())
        codes.put(ByteCode.ALoad, 1.toByte())
        codes.put(ByteCode.PutField, file.useField(file.selfClass, Name.State, Type.obj))
        codes.put(ByteCode.Return)
        file.addFn(
            "setState",
            ClassFile.Flag.Public,
            2U,
            Type.method(listOf(Type.obj), Type.void),
            codes
        )
    }

    private fun generateMain(file: ClassFile){
        val descriptor = Type.method(
            listOf(Type.array(Type.ref(Type.Cls.STR))),
            Type.void
        )
        val flag = ClassFile.Flag.Public or ClassFile.Flag.Static
        val codes = Codes(file)
        // new self object
        generateInvokeDefaultNew(file.selfClass, codes, file)
        codes.put(ByteCode.Dup)
        // make state
        codes.put(
            ByteCode.InvokeStatic,
            0,true,
            file.useClsMethod(Type.Cls.STATE, Name.Make, Type.method(null, Type.state))
        )
        // state * 2
        codes.put(ByteCode.Dup)
        // put field arg to state
        codes.put(ByteCode.ALoad, 0)
        codes.put(
            ByteCode.PutField,
            file.useField(Type.Cls.STATE, "gv\$arg", Type.obj)
        )
        // put field state to self
        codes.put(
            ByteCode.PutField,
            file.useField(file.selfClass, Name.State, Type.obj)
        )
        // invoke exec
        codes.put(ByteCode.AConstNull)
        codes.put(ByteCode.AConstNull)
        codes.put(
            ByteCode.InvokeVirtual,
            2,true,
            file.useClsMethod(file.selfClass, Name.Exec, Type.luaFn)
        )
        codes.put(ByteCode.Return)
        file.addFn(
            Name.Main,
            flag,
            1U,
            descriptor,
            codes
        )
    }

    private fun generateInvokeDefaultNew(cls : String, codes: Codes, file: ClassFile){
        codes.put(ByteCode.New, file.useClass(cls))
        codes.put(ByteCode.Dup)
        codes.put(ByteCode.InvokeSpecial,
            0,false,
            file.useClsMethod(cls, "<init>", "()V"))
    }


    private fun toVarName(loc : Location) : String{
        val prefix = when(loc.area){
            VarType.Global -> "gv"
            VarType.FieldUpValue -> "uv"
            VarType.Local -> ""
        }
        return "$prefix\$${loc.name}"
    }

    private fun toFuncName(idx : Int) = "f$idx"

    private fun generateModuleCall(file: ClassFile, fnCount : Int){
        // 0 : this, 1 : fnId, 2 : args, 3 : upValues
        assert(fnCount >= 0)
        val codes = Codes(file)
        codes.put(ByteCode.ILoad, 1.toByte())
        val switchLabel = codes.len()
        codes.put(ByteCode.TableSwitch)
        while (codes.len() % 4 != 0){
            codes.add(0.toByte())
        }
        // 3 int value : default, low, high
        val defaultIdx = codes.len()
        codes.add(0) // default
        codes.add(0) // low
        codes.add(fnCount-1) // high
        val tableStartIdx = codes.len()
        for (i in 0 until fnCount){
            // target address of jump
            codes.add(0)
        }
        for(i in 0 until fnCount){
            val label = codes.len()
            codes.set(tableStartIdx + i * 4, label - switchLabel)
            // this
            codes.put(ByteCode.ALoad, 0.toByte())
            // args
            codes.put(ByteCode.ALoad, 2.toByte())
            codes.put(ByteCode.ALoad, 3.toByte())
            // call
            codes.put(
                ByteCode.InvokeVirtual,
                2,true,
                file.useClsMethod(
                    file.selfClass,
                    toFuncName(i),
                    Type.luaFn
                )
            )
            codes.put(ByteCode.AReturn)
        }
        codes.set(defaultIdx, codes.len() - switchLabel)
        codes.put(ByteCode.AConstNull)
        codes.put(ByteCode.AReturn)

        file.addFn(
            Name.Call,
            ClassFile.Flag.Public,
            4U,
            Type.luaModCallFn,
            codes
        )
    }

    private fun generate(ctx : FnGenContext){
        // padding null and flatten array of arguments
        ctx.codes.put(ByteCode.ALoad, FnGenContext.ArgsIdx)
        generateFlattenPadding(ctx.params.size, ctx, ctx.hasVarArg)
        ctx.codes.put(ByteCode.AStore, FnGenContext.ArgsIdx)
        // restore the arguments
        ctx.params.forEachIndexed{ idx,loc ->
            ctx.codes.put(ByteCode.ALoad, FnGenContext.ArgsIdx)
            ctx.codes.putConst(idx)
            ctx.codes.put(ByteCode.AALoad)
            generateStoreVar(loc, ctx)
        }
        // restore the upValues
        ctx.fnMeta.captures.forEachIndexed { idx,cap ->
            ctx.codes.put(ByteCode.ALoad, FnGenContext.UpValuesIdx)
            ctx.codes.putConst(idx)
            ctx.codes.put(ByteCode.AALoad)
            generateStoreVar(cap.toLoc, ctx)
        }
        ctx.body.forEach {
            generate(it, ctx)
        }
        ctx.codes.put(ByteCode.AConstNull)
        ctx.codes.put(ByteCode.AReturn)
        ctx.completeFunc()
        ctx.file.addLuaFn(
            ctx.name,
            ctx.fnMeta.maxLocals.toUShort(),
            ctx.codes,
            ctx.name == Name.Exec
        )
    }

    private fun generate(stmt : Statement, ctx : FnGenContext){
        ctx.markLine(stmt.beginLine)
        when(stmt){
            is Block -> stmt.body.forEach{ generate(it, ctx) }
            is Discard -> {
                generate(stmt.expr, ctx)
                ctx.codes.put(ByteCode.Pop)
            }
            is LocalDeclare -> generateLocalAssign(stmt, ctx)
            is Assign     -> generateAssign(stmt.left, stmt.right, ctx)
            is IfElse     -> generateIfElse(stmt, ctx)
            is RepeatLoop -> generateRepeat(stmt, ctx)
            is WhileLoop  -> generateWhile(stmt, ctx)
            is ForEqLoop  -> generateForEq(stmt, ctx)
            is ForInLoop  -> generateForIn(stmt, ctx)
            is Break -> {
                ctx.codes.put(ByteCode.Goto)
                ctx.addLabelBreakIdx(ctx.codes.len())
                ctx.codes.add(0.toShort())
            }
            is Return -> {
                when(stmt.list.size){
                    0 -> ctx.codes.put(ByteCode.AConstNull)
                    else -> generateArray(stmt.list, ctx)
                }
                ctx.codes.put(ByteCode.AReturn)
            }
            is Goto -> {
                ctx.codes.put(ByteCode.GotoW)
                val targetOffsetIdx = ctx.codes.len()
                ctx.codes.add(0)
                ctx.gotos.add(Pair(stmt, targetOffsetIdx))
            }
            is Label -> {
                ctx.markJumpTarget()
                stmt.offset = ctx.codes.len()
            }
            is None -> {}
        }
    }

    private fun generate(expr : Expression, ctx : FnGenContext){
        ctx.markLine(expr.beginLine)
        when(expr){
            is Var -> generateLoadVar(expr.location!!, ctx)
            is BinOp -> generateBinOp(expr, ctx)
            is UnaryOp -> generateUnOp(expr, ctx)
            is Require -> generateRequire(expr, ctx)
            is DeclaredFunc -> generateFunc(expr, ctx)
            is FieldAccess -> generateFieldAccess(expr.obj, expr.fields, ctx)
            is FuncInvoke -> {
                // prepare fn and args, then call
                generate(expr.func, ctx)
                generateArray(expr.args, ctx)
                ctx.codes.put(
                    ByteCode.InvokeStatic,
                    2,true,
                    ctx.file.useClsMethod(
                        Type.Cls.LUA, Name.Call,
                        Type.method(listOf(Type.obj, Type.objArray), Type.obj)
                    )
                )
            }
            is LiteralFalse -> generateBool(false, ctx)
            is LiteralTrue  -> generateBool(true, ctx)
            is LiteralTable -> generateTable(expr.pairs, ctx)
            is LiteralNil -> ctx.codes.put(ByteCode.AConstNull)
            is LiteralInt -> generateInt(expr.int, ctx)
            is LiteralNum -> generateNum(expr.num, ctx)
            is LiteralStr -> generateStr(expr.str, ctx)
            is UsedProcMacro -> throw Exception()
        }
    }

    private fun generateFunc(func : DeclaredFunc, ctx: FnGenContext){
        val newCtx = FnGenContext(
            toFuncName(func.fnIdx),
            func.meta,
            func.body,
            ctx.globals,
            ctx.file,
            func.paramsLocations,
            hasVarArg = func.hasVarArg()
        )
        newCtx.markLine(func.beginLine)
        generate(newCtx)
        ctx.codes.put(ByteCode.ALoad, 0.toByte())
        ctx.codes.putConst(func.fnIdx)
        ctx.codes.putConst(func.meta.captures.size)
        ctx.codes.put(ByteCode.ANewArray, ctx.file.useClass(Type.Cls.OBJ))
        func.meta.captures.forEachIndexed { idx,capInfo ->
            ctx.codes.put(ByteCode.Dup)
            ctx.codes.putConst(idx)
            generateLoadVar(capInfo.fromLoc, ctx)
            ctx.codes.put(ByteCode.AAStore)
        }
        ctx.codes.put(
            ByteCode.InvokeStatic,
            ctx.file.useClsMethod(
                Type.Cls.MOD_FN,
                Name.Make,
                Type.method(listOf(Type.mod,Type.int,Type.objArray), Type.ref(Type.Cls.MOD_FN))
            )
        )
    }

    private fun generateRequire(require: Require, ctx: FnGenContext) {
//        println(require.loadPath)
        ctx.codes.put(ByteCode.ALoad, 0.toByte())
        ctx.codes.put(
            ByteCode.GetField,
            ctx.file.useField(ctx.file.selfClass, Name.State, Type.obj)
        )
        generateStr(require.loadPath, ctx)
        when(require.isJavaLib){
            true  -> ctx.codes.put(ByteCode.IConst1)
            false -> ctx.codes.put(ByteCode.IConst0)
        }
        ctx.codes.put(
            ByteCode.InvokeStatic,
            3,true,
            ctx.file.useClsMethod(
                Type.Cls.LUA,
                Name.Require,
                Type.method(listOf(Type.obj, Type.str, Type.bool), Type.obj)
            )
        )
    }

    private fun generateIfElse(ifElse: IfElse, ctx: FnGenContext){
        val labelJumpEndIndices = mutableListOf<Int>()
        for (branchIdx in 0..ifElse.branches.lastIndex) {
            val (cond, body) = ifElse.branches[branchIdx]
            when(cond){
                is LiteralTrue  -> ctx.codes.put(ByteCode.IConst1)
                is LiteralFalse -> ctx.codes.put(ByteCode.IConst0)
                else -> {
                    generate(cond, ctx)
                    generateJudge(ctx)
                }
            }
            // if true  -> continue exec
            // if false -> jump to next branch
            // body end -> jump to branches end
            ctx.codes.put(ByteCode.IfEq)
            val labelJumpNextIdx = ctx.codes.len()
            ctx.codes.add(0.toShort())
            for (stmt in body) {
                generate(stmt, ctx)
            }
            if (branchIdx < ifElse.branches.lastIndex){
                ctx.codes.put(ByteCode.GotoW)
                labelJumpEndIndices.add(ctx.codes.len())
                ctx.codes.add(0)
            }
            ctx.codes.set(labelJumpNextIdx, (ctx.codes.len() - labelJumpNextIdx + 1).toShort())
        }
        for (labelJumpEndIdx in labelJumpEndIndices) {
            ctx.codes.set(labelJumpEndIdx, ctx.codes.len() - labelJumpEndIdx + 1)
        }
    }

    private fun generateJudge(ctx: FnGenContext){
        ctx.codes.put(ByteCode.InvokeStatic,
            1, true,
            ctx.file.useClsMethod(
                Type.Cls.LUA,
                Name.Judge,
                Type.method(listOf(Type.ref(Type.Cls.OBJ)), Type.bool)
            )
        )
    }

    private fun generateWhile(whileLoop: WhileLoop, ctx: FnGenContext){
        val labelBegin = ctx.codes.len()
        generate(whileLoop.cond, ctx)
        generateJudge(ctx)
        // if true  -> continue exec
        // if false -> jump to end
        ctx.codes.put(ByteCode.IfEq)
        val labelJumpEndIdx = ctx.codes.len()
        ctx.codes.add(0.toShort())
        ctx.enterLoop()
        ctx.addLabelBreakIdx(labelJumpEndIdx)
        for (stmt in whileLoop.body) {
            generate(stmt,ctx)
        }
        val labelTarget = ctx.codes.len()
        // body end -> jump to begin
        ctx.codes.put(
            ByteCode.Goto,
            (labelBegin - labelTarget).toShort()
        )
        val labelEnd = ctx.codes.len()
        ctx.exitLoop(labelEnd)
    }

    private fun generateRepeat(repeatLoop: RepeatLoop, ctx: FnGenContext){
        val labelBegin = ctx.codes.len()
        ctx.enterLoop()
        for (stmt in repeatLoop.body) {
            generate(stmt,ctx)
        }
        // if false -> continue exec
        // if true  -> jump to begin
        generate(repeatLoop.cond, ctx)
        generateJudge(ctx)
        val jumpIdx = ctx.codes.len()
        ctx.codes.put(ByteCode.IfNe)
        ctx.codes.add((labelBegin - jumpIdx).toShort())
        ctx.exitLoop(ctx.codes.len())
    }

    private fun generateForEq(loop: ForEqLoop, ctx: FnGenContext){
        // make the iter object, which will always exists in operand stack during for loop
        generate(loop.start, ctx)
        generate(loop.limit, ctx)
        if(loop.step == null){
            generateInt(1L, ctx)
        }else{
            generate(loop.step, ctx)
        }
        ctx.codes.put(
            ByteCode.InvokeStatic,
            3,true,
            ctx.file.useClsMethod(
                Type.Cls.INT_ITER,
                Name.Make,
                Type.method(listOf(Type.obj,Type.obj,Type.obj), Type.luaIter)
            )
        )
        val labelBegin = ctx.codes.len()
        // invoke iter.next
        ctx.codes.put(ByteCode.Dup)
        ctx.codes.put(
            ByteCode.InvokeVirtual,
            0,true,
            ctx.file.useClsMethod(
                Type.Cls.ITER,
                Name.Next,
                Type.method(null, Type.obj)
            )
        )
        generateStoreVar(loop.location!!, ctx)
        // jump to end if result of iter.next is null
        generateLoadVar(loop.location!!, ctx)
        ctx.codes.put(ByteCode.IfNull)
        val labelBreakIdx = ctx.codes.len()
        ctx.codes.add(0.toShort())
        // for loop body
        ctx.enterLoop()
        ctx.addLabelBreakIdx(labelBreakIdx)
        for (stmt in loop.body) {
            generate(stmt, ctx)
        }
        ctx.codes.put(ByteCode.Goto, (labelBegin - ctx.codes.len()).toShort())
        val labelEnd = ctx.codes.len()
        ctx.exitLoop(labelEnd)
        // pop the iter object
        ctx.codes.put(ByteCode.Pop)
    }

    private fun generateForIn(loop : ForInLoop, ctx: FnGenContext){
        // get the iter object, which will always exists in operand stack during for loop
        generate(loop.iter, ctx)
        ctx.codes.put(ByteCode.CheckCast, ctx.file.useClass(Type.Cls.ITER))
        val labelBegin = ctx.codes.len()
        ctx.codes.put(ByteCode.Dup)
        // invoke iter.next
        ctx.codes.put(
            ByteCode.InvokeVirtual,
            0,true,
            ctx.file.useClsMethod(
                Type.Cls.ITER,
                Name.Next,
                Type.method(null, Type.obj)
            )
        )
        // assign to variables
        generateFlattenPadding(loop.locations.size, ctx)
        loop.locations.forEachIndexed { idx,loc ->
            ctx.codes.put(ByteCode.Dup)
            ctx.codes.putConst(idx)
            ctx.codes.put(ByteCode.AALoad)
            generateStoreVar(loc, ctx)
        }
        ctx.codes.put(ByteCode.Pop)
        // check if the first variable is null, if true then jump to end
        generateLoadVar(loop.locations.first(), ctx)
        ctx.codes.put(ByteCode.IfNull)
        val labelBreakIdx = ctx.codes.len()
        ctx.codes.add(0.toShort())
        // for loop body
        ctx.enterLoop()
        ctx.addLabelBreakIdx(labelBreakIdx)
        for (stmt in loop.body) {
            generate(stmt, ctx)
        }
        ctx.codes.put(ByteCode.Goto, (labelBegin - ctx.codes.len()).toShort())
        val labelEnd = ctx.codes.len()
        ctx.exitLoop(labelEnd)
        // pop the iter object
        ctx.codes.put(ByteCode.Pop)
    }

    private fun generateAssign(left : List<Expression>, right : List<Expression>, ctx : FnGenContext){
        generateArray(right, ctx)
        generateFlattenPadding(left.size, ctx)
        left.forEachIndexed { idx, leftVal ->
            ctx.codes.put(ByteCode.Dup)
            ctx.codes.putConst(idx)
            ctx.codes.put(ByteCode.AALoad)
            when (leftVal) {
                is Var -> generateStoreVar(leftVal.location!!, ctx)
                is FieldAccess -> generateFieldPut(leftVal, ctx)
                else -> throw Exception()
            }
        }
        // pop the ARRAY
        ctx.codes.put(ByteCode.Pop)
    }

    // prepare [object, key, value] in stack and invoke Lua.put
    private fun generateFieldPut(put : FieldAccess, ctx: FnGenContext){
        assert(put.fields.isNotEmpty())
        // [val][obj]
        generateFieldAccess(put.obj, put.fields.subList(0,put.fields.lastIndex), ctx)
        // [obj][val]
        ctx.codes.put(ByteCode.DupX1).put(ByteCode.Pop)
        // [obj][val][key]
        generate(put.fields.last(), ctx)
        // [obj][key][val]
        ctx.codes.put(ByteCode.DupX1).put(ByteCode.Pop)
        // []
        ctx.codes.put(
            ByteCode.InvokeStatic,
            3, false,
            ctx.file.useClsMethod(
                Type.Cls.LUA,
                Name.Put,
                Type.method(listOf(Type.obj,Type.obj,Type.obj), Type.void)
            )
        )
    }

    private fun generateFieldAccess(obj : Expression, fields : List<Expression>, ctx: FnGenContext){
        generate(obj, ctx)
        for (field in fields) {
            generate(field, ctx)
            ctx.codes.put(
                ByteCode.InvokeStatic,
                2, true,
                ctx.file.useClsMethod(
                    Type.Cls.LUA,
                    Name.Access,
                    Type.method(listOf(Type.obj,Type.obj), Type.obj)
                )
            )
        }
    }

    private fun generateLocalAssign(decl : LocalDeclare, ctx: FnGenContext){
        generateArray(decl.right, ctx)
        generateFlattenPadding(decl.left.size, ctx)
        // now we have an ARRAY on top of operand stack, begin variable assign
        decl.locations.forEachIndexed { idx,loc ->
            ctx.codes.put(ByteCode.Dup)
            ctx.codes.putConst(idx)
            ctx.codes.put(ByteCode.AALoad)
            generateStoreVar(loc, ctx)
        }
        // pop the ARRAY
        ctx.codes.put(ByteCode.Pop)
    }

    private fun generateFlattenPadding(needLen : Int, ctx : FnGenContext, hasVarArg : Boolean = false){
        val finalNeedLen = if (hasVarArg) 10000 + needLen else needLen
        ctx.codes.putConst(finalNeedLen)
        ctx.codes.put(
            ByteCode.InvokeStatic,
            2,true,
            ctx.file.useClsMethod(
                Type.Cls.LUA,
                Name.Flatten,
                Type.method(listOf(Type.objArray, Type.int), Type.objArray)
            )
        )
    }

    // local var : ALoad n, AStore n / GetField #n, PutField #n
    // up val : GetField #n, PutField #n
    // global var : GetField #n, PutField #n
    private fun generateLoadVar(location : Location, ctx : FnGenContext){
        val idx = location.idx
        when(location.area){
            VarType.Global -> {
                ctx.codes.put(ByteCode.ALoad, 0.toByte())
                ctx.codes.put(ByteCode.GetField, ctx.file.useField(ctx.file.selfClass, Name.State, Type.obj))
                ctx.codes.put(ByteCode.CheckCast, ctx.file.useClass(Type.Cls.STATE))
                ctx.codes.put(ByteCode.GetField, ctx.file.useField(Type.Cls.STATE, toVarName(location), Type.obj))
            }
            VarType.FieldUpValue -> {
                ctx.codes.put(ByteCode.ALoad, 0.toByte())
                ctx.codes.put(ByteCode.GetField, ctx.file.useField(ctx.file.selfClass, toVarName(location), Type.obj))
            }
            VarType.Local -> {
                if (idx > UByte.MAX_VALUE.toInt()) {
                    ctx.codes.put(ByteCode.Wide).put(ByteCode.ALoad, idx.toUShort())
                } else {
                    ctx.codes.put(ByteCode.ALoad, idx.toUByte())
                }
            }
        }
    }

    private fun generateStoreVar(location: Location, ctx : FnGenContext){
        when (location.area) {
            VarType.Local -> {
                if(location.idx < UByte.MAX_VALUE.toInt()){
                    ctx.codes.put(ByteCode.AStore, location.idx.toUByte())
                }else{
                    ctx.codes.put(ByteCode.Wide)
                    ctx.codes.put(ByteCode.AStore, location.idx.toUShort())
                }
                return
            }
            VarType.Global -> {
                val symbol = toVarName(location)
                // [value][this]
                ctx.codes.put(ByteCode.ALoad, 0.toByte())
                // [value][state]
                ctx.codes.put(
                    ByteCode.GetField,
                    ctx.file.useField(ctx.file.selfClass, Name.State, Type.obj)
                )
                ctx.codes.put(ByteCode.CheckCast, ctx.file.useClass(Type.Cls.STATE))
                // [state][value][state]
                ctx.codes.put(ByteCode.DupX1)
                // [state][value]
                ctx.codes.put(ByteCode.Pop)
                ctx.codes.put(
                    ByteCode.PutField,
                    ctx.file.useField(Type.Cls.STATE, symbol, Type.obj)
                )
            }
            VarType.FieldUpValue -> {
                val symbol = toVarName(location)
                // [value][this]
                ctx.codes.put(ByteCode.ALoad, 0.toByte())
                // [this][val][this]
                ctx.codes.put(ByteCode.DupX1)
                // [this][val]
                ctx.codes.put(ByteCode.Pop)
                ctx.codes.put(
                    ByteCode.PutField,
                    ctx.file.useField(ctx.file.selfClass, symbol, Type.obj)
                )
            }
        }

    }

    private fun generateArray(list : List<Expression>, ctx: FnGenContext){
        ctx.codes.putConst(list.size)
        ctx.codes.put(ByteCode.ANewArray, ctx.file.useClass(Type.Cls.OBJ))
        list.forEachIndexed { idx, argExpr ->
            ctx.codes.put(ByteCode.Dup)
            ctx.codes.putConst(idx)
            generate(argExpr, ctx)
            ctx.codes.put(ByteCode.AAStore)
        }
    }
    
    private object LuaOpFn{
        const val ADD = "add"
        const val SUB = "sub"
        const val MUL = "mul"
        const val DIV = "div"
        const val MOD = "mod"
        const val POW = "pow"
        const val UNM = "unm"
        const val IDIV = "idiv"
        const val BAND = "band"
        const val BOR = "bor"
        const val BXOR = "bxor"
        const val BNOT = "bnot"
        const val SHL = "shl"
        const val SHR = "shr"
        const val CONCAT = "concat"
        const val LEN = "len"
        const val EQ = "eq"
        const val LT = "lt"
        const val LE = "le"
        const val NOT = "not"
        const val GT = "gt"
        const val GE = "ge"
        const val NE = "ne"
    }

    private fun generateBinOp(binOp: BinOp, ctx : FnGenContext){
        generate(binOp.left, ctx)
        for (pair in binOp.then) {
            val (op, right) = pair
            // ======= Short Circuit Evaluation =======
            if(op == BinOpType.Or || op == BinOpType.And){
                ctx.codes.put(ByteCode.Dup)
                ctx.codes.put(ByteCode.InvokeStatic,
                    1,true,
                    ctx.file.useClsMethod(
                        Type.Cls.LUA,
                        Name.Judge,
                        Type.method(listOf(Type.ref(Type.Cls.OBJ)), Type.bool)
                    )
                )
                if(op == BinOpType.Or){
                    // if(flag) use 'left', jump to BinOp end
                    ctx.codes.put(ByteCode.IfNe)
                }else{
                    // if(!flag) use 'left', jump to BinOp end
                    ctx.codes.put(ByteCode.IfEq)
                }
                val labelIdx : Int = ctx.codes.len()
                ctx.codes.add(0.toShort())
                // if not jump, means discard 'left'
                ctx.codes.put(ByteCode.Pop)
                generate(right, ctx)
                val currIdx = ctx.codes.len()
                ctx.codes.set(labelIdx, (currIdx - labelIdx + 1).toShort())
                continue
            }
            // ======= Normal Evaluation =======
            generate(right, ctx)
            // invoke Lua.<op>
            val fnName = when(op){
                BinOpType.Add -> LuaOpFn.ADD
                BinOpType.Sub -> LuaOpFn.SUB
                BinOpType.Mul -> LuaOpFn.MUL
                BinOpType.Div -> LuaOpFn.DIV
                BinOpType.Mod -> LuaOpFn.MOD
                BinOpType.Pow -> LuaOpFn.POW
                BinOpType.DivNoRem -> LuaOpFn.IDIV
                BinOpType.BitAnd -> LuaOpFn.BAND
                BinOpType.BitOr -> LuaOpFn.BOR
                BinOpType.Concat -> LuaOpFn.CONCAT
                BinOpType.LShift -> LuaOpFn.SHL
                BinOpType.RShift -> LuaOpFn.SHR
                BinOpType.Eqs -> LuaOpFn.EQ
                BinOpType.BitXor -> LuaOpFn.BXOR
                BinOpType.Lt -> LuaOpFn.LT
                BinOpType.LtEq -> LuaOpFn.LE
                // â†“ In fact are NOT meta functions
                BinOpType.Gt -> LuaOpFn.GT
                BinOpType.GtEq -> LuaOpFn.GE
                BinOpType.NotEq -> LuaOpFn.NE
                // unused, never reach here
                // and, or
                else -> ""
            }
            ctx.codes.put(
                ByteCode.InvokeStatic,
                2,true,
                ctx.file.useClsMethod(
                    Type.Cls.LUA,
                    fnName,
                    Type.binaryOpFn
                )
            )
        }
    }

    private fun generateUnOp(expr: UnaryOp, ctx: FnGenContext) {
        generate(expr.inner, ctx)
        val opFnName = when(expr.op){
            Neg -> LuaOpFn.UNM
            Not -> LuaOpFn.NOT
            GetLen -> LuaOpFn.LEN
            BitNot -> LuaOpFn.BNOT
        }
        ctx.codes.put(
            ByteCode.InvokeStatic,
            1,true,
            ctx.file.useClsMethod(
                Type.Cls.LUA,
                opFnName,
                Type.unaryOpFn
            )
        )
    }

    private fun generateTable(kvPairs: MutableList<Pair<Expression, Expression>>, ctx: FnGenContext) {
        ctx.codes.putConst(kvPairs.size)
        ctx.codes.put(
            ByteCode.InvokeStatic,
            1,true,
            ctx.file.useClsMethod(
                Type.Cls.TABLE,
                Name.Make,
                Type.method(listOf(Type.int), Type.table)
            )
        )
        kvPairs.forEach {
            ctx.codes.put(ByteCode.Dup)
            generate(it.first, ctx)
            generate(it.second, ctx)
            ctx.codes.put(
                ByteCode.InvokeVirtual,
                2,true,
                ctx.file.useClsMethod(
                    Type.Cls.TABLE,
                    Name.Put,
                    Type.method(listOf(Type.obj, Type.obj), Type.obj)
                )
            )
            ctx.codes.put(ByteCode.Pop)
        }
    }

    private fun generateInt(n : Long, ctx : FnGenContext){
        val codes = ctx.codes
        when(n){
            0L  -> codes.put(ByteCode.LConst0)
            1L  -> codes.put(ByteCode.LConst1)
            -1L -> codes.put(ByteCode.IConstM1).put(ByteCode.I2L)
            2L  -> codes.put(ByteCode.IConst2).put(ByteCode.I2L)
            3L  -> codes.put(ByteCode.IConst3).put(ByteCode.I2L)
            4L  -> codes.put(ByteCode.IConst4).put(ByteCode.I2L)
            5L  -> codes.put(ByteCode.IConst5).put(ByteCode.I2L)
            in Byte.MIN_VALUE..Byte.MAX_VALUE -> {
                codes.put(ByteCode.BIPush, n.toByte())
                codes.put(ByteCode.I2L)
            }
            in Short.MIN_VALUE..Short.MAX_VALUE -> {
                codes.put(ByteCode.SIPush, n.toShort())
                codes.put(ByteCode.I2L)
            }
            in Int.MIN_VALUE..Int.MAX_VALUE -> {
                val idx = ctx.file.useInt(n.toInt())
                if(idx < UByte.MAX_VALUE){
                    codes.put(ByteCode.LDC, idx.toUByte())
                }else{
                    codes.put(ByteCode.LDC_W, idx)
                }
                codes.put(ByteCode.I2L)
            }
            else -> {
                val idx = ctx.file.useLong(n)
                codes.put(ByteCode.LDC2W, idx)
            }
        }
        codes.put(
            ByteCode.InvokeStatic,
            1,true,
            ctx.file.useClsMethod(
                Type.Cls.LONG,
                Name.ValueOf,
                Type.method(listOf(Type.long), Type.ref(Type.Cls.LONG))
            )
        )
    }

    private fun generateNum(n : Double, ctx : FnGenContext){
        val codes = ctx.codes
        when(n){
            0.0  -> codes.put(ByteCode.DConst0)
            1.0  -> codes.put(ByteCode.DConst1)
            2.0  -> codes.put(ByteCode.FConst2).put(ByteCode.F2D)
            else -> codes.put(ByteCode.LDC2W, ctx.file.useDouble(n))
        }
        codes.put(
            ByteCode.InvokeStatic,
            1,true,
            ctx.file.useClsMethod(
                Type.Cls.DOUBLE,
                Name.ValueOf,
                Type.method(listOf(Type.double), Type.ref(Type.Cls.DOUBLE))
            )
        )
    }

    private fun generateStr(s : String, ctx : FnGenContext){
        val conStrIdx = ctx.file.useString(s)
        if(conStrIdx < UByte.MAX_VALUE){
            ctx.codes.put(ByteCode.LDC, conStrIdx.toUByte())
        }else{
            ctx.codes.put(ByteCode.LDC_W, conStrIdx)
        }
    }

    private fun generateBool(bool : Boolean, ctx : FnGenContext){
        when(bool){
            true  -> ctx.codes.put(ByteCode.IConst1)
            false -> ctx.codes.put(ByteCode.IConst0)
        }
        ctx.codes.put(
            ByteCode.InvokeStatic,
            1,true,
            ctx.file.useClsMethod(
                Type.Cls.BOOL,
                Name.ValueOf,
                Type.method(listOf(Type.bool), Type.ref(Type.Cls.BOOL))
            )
        )
    }
}